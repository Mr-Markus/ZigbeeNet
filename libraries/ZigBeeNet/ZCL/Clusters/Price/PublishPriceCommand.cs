using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ZigBeeNet.Security;
using ZigBeeNet.ZCL.Clusters.Price;
using ZigBeeNet.ZCL.Field;
using ZigBeeNet.ZCL.Protocol;


namespace ZigBeeNet.ZCL.Clusters.Price
{
    /// <summary>
    /// Publish Price Command value object class.
    ///
    /// Cluster: Price. Command ID 0x00 is sent FROM the server.
    /// This command is a specific command used for the Price cluster.
    ///
    /// The Publish Price command is generated in response to receiving a Get Current Price
    /// command, in response to a Get Scheduled Prices command, and when an update to the pricing
    /// information is available from the commodity provider, either before or when a TOU price
    /// becomes active. Additionally the Publish Price Command is generated when Block
    /// Pricing is in effect. When a Get Current Price or Get Scheduled Prices command is
    /// received over a ZigBee Smart Energy network, the Publish Price command should be sent
    /// unicast to the requester. In the case of an update to the pricing information from the
    /// commodity provider, the Publish Price command should be unicast to all individually
    /// registered devices implementing the Price Cluster on the ZigBee Smart Energy network.
    /// <br> Devices capable of receiving this command must be capable of storing and
    /// supporting at least two pricing information instances, the current active price and
    /// the next price. By supporting at least two pricing information instances, receiving
    /// devices will allow the Publish Price command generator to publish the next pricing
    /// information during the current pricing period. <br> Nested and overlapping Publish
    /// Price commands are not allowed. The current active price will be replaced if new price
    /// information is received by the ESI. In the case of overlapping events, the event with the
    /// newer Issuer Event ID takes priority over all nested and overlapping events. All
    /// existing events that overlap, even partially, should be removed. The only exception to
    /// this is that if an event with a newer Issuer Event ID overlaps with the end of the current
    /// active price but is not yet active, the active price is not deleted but its duration is
    /// modified to 0xFFFF (until changed) so that the active price ends when the new event
    /// begins.
    ///
    /// Code is auto-generated. Modifications may be overwritten!
    /// </summary>
    public class PublishPriceCommand : ZclCommand
    {
        /// <summary>
        /// The cluster ID to which this command belongs.
        /// </summary>
        public const ushort CLUSTER_ID = 0x0700;

        /// <summary>
        /// The command ID.
        /// </summary>
        public const byte COMMAND_ID = 0x00;

        /// <summary>
        /// Provider ID command message field.
        /// 
        /// An unsigned 32-bit field containing a unique identifier for the commodity
        /// provider. This field allows differentiation in deregulated markets where
        /// multiple commodity providers may be available.
        /// </summary>
        public uint ProviderId { get; set; }

        /// <summary>
        /// Rate Label command message field.
        /// 
        /// A ZCL Octet String field capable of storing a 12 character string (the first Octet
        /// indicates length) containing commodity provider- specific information
        /// regarding the current billing rate. The String shall be encoded in the UTF-8
        /// format. This field allows differentiation when a commodity provider may have
        /// multiple pricing plans.
        /// </summary>
        public ByteArray RateLabel { get; set; }

        /// <summary>
        /// Issuer Event ID command message field.
        /// 
        /// Unique identifier generated by the commodity provider. When new pricing
        /// information is provided that replaces older pricing information for the same time
        /// period, this field allows devices to determine which information is newer. It is
        /// expected that the value contained in this field is a unique number managed by
        /// upstream servers or a UTC based time stamp (UTCTime data type) identifying when the
        /// Publish Price command was issued. Thus, newer pricing information will have a
        /// value in the Issuer Event ID field that is larger than older pricing information.
        /// </summary>
        public uint IssuerEventId { get; set; }

        /// <summary>
        /// Current Time command message field.
        /// 
        /// A UTCTime field containing the current time as determined by the device. This field
        /// provides an extra value-added feature for the broadcast price signals.
        /// </summary>
        public DateTime CurrentTime { get; set; }

        /// <summary>
        /// Unit Of Measure command message field.
        /// 
        /// An 8-bit enumeration field identifying the commodity as well as its base unit of
        /// measure. The enumeration used for this field shall match one of the UnitOfMeasure
        /// values using a pure binary format as defined in the Metering cluster.
        /// </summary>
        public byte UnitOfMeasure { get; set; }

        /// <summary>
        /// Currency command message field.
        /// 
        /// An unsigned 16-bit field containing identifying information concerning the
        /// local unit of currency used in the price field. This field allows the displaying of
        /// the appropriate symbol for a currency (i.e.: $). The value of the currency field
        /// should match the values defined by ISO 4217. Price Trailing Digit and Price Tier
        /// (mandatory): An 8-bit field used to determine where the decimal point is located in
        /// the price field and to indicate the current pricing tier as chosen by the commodity
        /// provider. The most significant nibble is the Trailing Digit sub-field which
        /// indicates the number of digits to the right of the decimal point. The least
        /// significant nibble is an enumerated field containing the current Price Tier. An
        /// 8-bit BitMap where the most significant nibble is an enumerated sub-field
        /// representing the maximum number of price tiers available, and the least
        /// significant nibble is an enumerated sub-field indicating the register tier used
        /// with the current Price Tier. Valid values for the Number of Price Tiers sub-field
        /// are from 0 to 15 reflecting no tiers in use (0) to fifteen or more tiers available
        /// (15). The meaning of value 0xF is dependant on the value of the optional the Extended
        /// Number of Price Tiers field. Absence of this field, or a value of 0x00 in this field,
        /// indicates that maximum number of tiers available is fifteen. Where the Extended
        /// Number of Price Tiers field contains a non-zero value, the maximum number of tiers
        /// available is determined by the sum of the values of the Number of Price Tiers
        /// sub-field and the Extended Number of Price Tiers field.
        /// </summary>
        public ushort Currency { get; set; }

        /// <summary>
        /// Price Trailing Digit And Tier command message field.
        /// </summary>
        public byte PriceTrailingDigitAndTier { get; set; }

        /// <summary>
        /// Number Of Price Tiers command message field.
        /// </summary>
        public byte NumberOfPriceTiers { get; set; }

        /// <summary>
        /// Start Time command message field.
        /// 
        /// A UTCTime field to denote the time at which the price signal becomes valid. A Start
        /// Time of 0x00000000 is a special time denoting “now”. If the device would send a price
        /// with a Start Time of now, adjust the Duration In Minutes field to correspond to the
        /// remainder of the price. An unsigned 16-bit field used to denote the amount of time in
        /// minutes after the Start Time during which the price signal is valid. Maximum value
        /// means “until changed”. If Block Charging only is in use, the Duration in Minutes
        /// field of the Publish Price command shall be set to 0xFFFF indicating the price is
        /// valid “until changed”.
        /// </summary>
        public DateTime StartTime { get; set; }

        /// <summary>
        /// Duration command message field.
        /// </summary>
        public ushort Duration { get; set; }

        /// <summary>
        /// Price command message field.
        /// 
        /// An unsigned 32-bit field containing the price of the commodity measured in base
        /// unit of Currency per Unit of Measure with the decimal point located as indicated by
        /// the Price Trailing Digit field when the commodity is delivered to the premises.
        /// </summary>
        public uint Price { get; set; }

        /// <summary>
        /// Price Ratio command message field.
        /// 
        /// An unsigned 8-bit field that gives the ratio of the price denoted in the Price field
        /// to the “normal” price chosen by the commodity provider. This field is thought to be
        /// useful in situations where CLIENT devices may simply be interested in pricing
        /// levels or ratios. The value in this field should be scaled by a factor of 0.1, giving a
        /// range of ratios from 0.1 to 25.4. A value of 0xFF indicates the field is not used and
        /// 0x00 is an invalid value.
        /// </summary>
        public byte PriceRatio { get; set; }

        /// <summary>
        /// Generation Price command message field.
        /// 
        /// An unsigned 32-bit field containing the price of the commodity measured in base
        /// unit of Currency per Unit of Measure with the decimal point located as indicated by
        /// the Price Trailing Digit field when the commodity is received from the premises. An
        /// example use of this field is in energy markets where the price of electricity from
        /// the grid is different than the price of electricity placed on the grid. A value of
        /// 0xFFFFFFFF indicates the field is not used.
        /// </summary>
        public uint GenerationPrice { get; set; }

        /// <summary>
        /// Generation Price Ratio command message field.
        /// 
        /// An unsigned 8-bit field that gives the ratio of the price denoted in the Generation
        /// Price field to the “normal” price chosen by the commodity provider. This field is
        /// thought to be useful in situations where CLIENT devices may simply be interested in
        /// pricing levels or ratios. The value in this field should be scaled by a factor of 0.1,
        /// giving a range of ratios from 0.1 to 25.4 A value of 0xFF indicates the field is not
        /// used and 0x00 is an invalid value.
        /// </summary>
        public uint GenerationPriceRatio { get; set; }

        /// <summary>
        /// Alternate Cost Delivered command message field.
        /// 
        /// An unsigned 32-bit Integer field that provides a mechanism to describe an
        /// alternative measure of the cost of the energy consumed. An example of an Alternate
        /// Cost might be the emissions of CO2 for each kWh of electricity consumed providing a
        /// measure of the environmental cost. Another example is the emissions of CO2 for each
        /// cubic meter of gas consumed (for gas metering). A different value for each price
        /// tier may be provided which can be used to reflect the different mix of generation
        /// that is associated with different TOU rates. A value of 0xFFFFFFFF indicates the
        /// field is not used.
        /// </summary>
        public uint AlternateCostDelivered { get; set; }

        /// <summary>
        /// Alternate Cost Unit command message field.
        /// 
        /// An 8-bit enumeration identifying the unit for the Alternate Cost Delivered field.
        /// A value of 0xFF indicates the field is not used.
        /// </summary>
        public byte AlternateCostUnit { get; set; }

        /// <summary>
        /// Alternate Cost Trailing Digit command message field.
        /// </summary>
        public byte AlternateCostTrailingDigit { get; set; }

        /// <summary>
        /// Number Of Block Thresholds command message field.
        /// </summary>
        public byte NumberOfBlockThresholds { get; set; }

        /// <summary>
        /// Price Control command message field.
        /// </summary>
        public byte PriceControl { get; set; }

        /// <summary>
        /// Number Of Generation Tiers command message field.
        /// </summary>
        public byte NumberOfGenerationTiers { get; set; }

        /// <summary>
        /// Generation Tier command message field.
        /// </summary>
        public byte GenerationTier { get; set; }

        /// <summary>
        /// Extended Number Of Price Tiers command message field.
        /// </summary>
        public byte ExtendedNumberOfPriceTiers { get; set; }

        /// <summary>
        /// Extended Price Tier command message field.
        /// </summary>
        public byte ExtendedPriceTier { get; set; }

        /// <summary>
        /// Extended Register Tier command message field.
        /// </summary>
        public byte ExtendedRegisterTier { get; set; }

        /// <summary>
        /// Default constructor.
        /// </summary>
        public PublishPriceCommand()
        {
            ClusterId = CLUSTER_ID;
            CommandId = COMMAND_ID;
            GenericCommand = false;
            CommandDirection = ZclCommandDirection.SERVER_TO_CLIENT;
        }

        internal override void Serialize(ZclFieldSerializer serializer)
        {
            serializer.Serialize(ProviderId, ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            serializer.Serialize(RateLabel, ZclDataType.Get(DataType.OCTET_STRING));
            serializer.Serialize(IssuerEventId, ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            serializer.Serialize(CurrentTime, ZclDataType.Get(DataType.UTCTIME));
            serializer.Serialize(UnitOfMeasure, ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            serializer.Serialize(Currency, ZclDataType.Get(DataType.UNSIGNED_16_BIT_INTEGER));
            serializer.Serialize(PriceTrailingDigitAndTier, ZclDataType.Get(DataType.BITMAP_8_BIT));
            serializer.Serialize(NumberOfPriceTiers, ZclDataType.Get(DataType.BITMAP_8_BIT));
            serializer.Serialize(StartTime, ZclDataType.Get(DataType.UTCTIME));
            serializer.Serialize(Duration, ZclDataType.Get(DataType.UNSIGNED_16_BIT_INTEGER));
            serializer.Serialize(Price, ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            serializer.Serialize(PriceRatio, ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER));
            serializer.Serialize(GenerationPrice, ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            serializer.Serialize(GenerationPriceRatio, ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            serializer.Serialize(AlternateCostDelivered, ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            serializer.Serialize(AlternateCostUnit, ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            serializer.Serialize(AlternateCostTrailingDigit, ZclDataType.Get(DataType.BITMAP_8_BIT));
            serializer.Serialize(NumberOfBlockThresholds, ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER));
            serializer.Serialize(PriceControl, ZclDataType.Get(DataType.BITMAP_8_BIT));
            serializer.Serialize(NumberOfGenerationTiers, ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER));
            serializer.Serialize(GenerationTier, ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            serializer.Serialize(ExtendedNumberOfPriceTiers, ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            serializer.Serialize(ExtendedPriceTier, ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            serializer.Serialize(ExtendedRegisterTier, ZclDataType.Get(DataType.ENUMERATION_8_BIT));
        }

        internal override void Deserialize(ZclFieldDeserializer deserializer)
        {
            ProviderId = deserializer.Deserialize<uint>(ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            RateLabel = deserializer.Deserialize<ByteArray>(ZclDataType.Get(DataType.OCTET_STRING));
            IssuerEventId = deserializer.Deserialize<uint>(ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            CurrentTime = deserializer.Deserialize<DateTime>(ZclDataType.Get(DataType.UTCTIME));
            UnitOfMeasure = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            Currency = deserializer.Deserialize<ushort>(ZclDataType.Get(DataType.UNSIGNED_16_BIT_INTEGER));
            PriceTrailingDigitAndTier = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.BITMAP_8_BIT));
            NumberOfPriceTiers = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.BITMAP_8_BIT));
            StartTime = deserializer.Deserialize<DateTime>(ZclDataType.Get(DataType.UTCTIME));
            Duration = deserializer.Deserialize<ushort>(ZclDataType.Get(DataType.UNSIGNED_16_BIT_INTEGER));
            Price = deserializer.Deserialize<uint>(ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            PriceRatio = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER));
            GenerationPrice = deserializer.Deserialize<uint>(ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            GenerationPriceRatio = deserializer.Deserialize<uint>(ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            AlternateCostDelivered = deserializer.Deserialize<uint>(ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER));
            AlternateCostUnit = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            AlternateCostTrailingDigit = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.BITMAP_8_BIT));
            NumberOfBlockThresholds = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER));
            PriceControl = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.BITMAP_8_BIT));
            NumberOfGenerationTiers = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER));
            GenerationTier = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            ExtendedNumberOfPriceTiers = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            ExtendedPriceTier = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.ENUMERATION_8_BIT));
            ExtendedRegisterTier = deserializer.Deserialize<byte>(ZclDataType.Get(DataType.ENUMERATION_8_BIT));
        }

        public override string ToString()
        {
            var builder = new StringBuilder();

            builder.Append("PublishPriceCommand [");
            builder.Append(base.ToString());
            builder.Append(", ProviderId=");
            builder.Append(ProviderId);
            builder.Append(", RateLabel=");
            builder.Append(RateLabel);
            builder.Append(", IssuerEventId=");
            builder.Append(IssuerEventId);
            builder.Append(", CurrentTime=");
            builder.Append(CurrentTime);
            builder.Append(", UnitOfMeasure=");
            builder.Append(UnitOfMeasure);
            builder.Append(", Currency=");
            builder.Append(Currency);
            builder.Append(", PriceTrailingDigitAndTier=");
            builder.Append(PriceTrailingDigitAndTier);
            builder.Append(", NumberOfPriceTiers=");
            builder.Append(NumberOfPriceTiers);
            builder.Append(", StartTime=");
            builder.Append(StartTime);
            builder.Append(", Duration=");
            builder.Append(Duration);
            builder.Append(", Price=");
            builder.Append(Price);
            builder.Append(", PriceRatio=");
            builder.Append(PriceRatio);
            builder.Append(", GenerationPrice=");
            builder.Append(GenerationPrice);
            builder.Append(", GenerationPriceRatio=");
            builder.Append(GenerationPriceRatio);
            builder.Append(", AlternateCostDelivered=");
            builder.Append(AlternateCostDelivered);
            builder.Append(", AlternateCostUnit=");
            builder.Append(AlternateCostUnit);
            builder.Append(", AlternateCostTrailingDigit=");
            builder.Append(AlternateCostTrailingDigit);
            builder.Append(", NumberOfBlockThresholds=");
            builder.Append(NumberOfBlockThresholds);
            builder.Append(", PriceControl=");
            builder.Append(PriceControl);
            builder.Append(", NumberOfGenerationTiers=");
            builder.Append(NumberOfGenerationTiers);
            builder.Append(", GenerationTier=");
            builder.Append(GenerationTier);
            builder.Append(", ExtendedNumberOfPriceTiers=");
            builder.Append(ExtendedNumberOfPriceTiers);
            builder.Append(", ExtendedPriceTier=");
            builder.Append(ExtendedPriceTier);
            builder.Append(", ExtendedRegisterTier=");
            builder.Append(ExtendedRegisterTier);
            builder.Append(']');

            return builder.ToString();
        }
    }
}
