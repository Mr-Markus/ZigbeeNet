
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using ZigBeeNet.DAO;
using ZigBeeNet.Security;
using ZigBeeNet.ZCL.Clusters.DoorLock;
using ZigBeeNet.ZCL.Field;
using ZigBeeNet.ZCL.Protocol;


namespace ZigBeeNet.ZCL.Clusters
{
    /// <summary>
    /// Door Lock cluster implementation (Cluster ID 0x0101).
    ///
    /// The door lock cluster provides an interface to a generic way to secure a door. The
    /// physical object that provides the locking functionality is abstracted from the
    /// cluster. The cluster has a small list of mandatory attributes and functions and a list of
    /// optional features.
    /// Generally the door lock itself implements the server side of this cluster. The
    /// attributes and commands listed in this cluster were developed to be implemented by a
    /// door lock which has the ability to keep track of multiple users and schedules.
    /// The door lock cluster provides several alarms which can be sent when there is a critical
    /// state on the door lock. The alarms available for the door lock cluster are listed in the
    /// section below outlining the alarm mask at- tribute. The Alarm cluster is used to
    /// generate the actual alarms.
    /// The event mechanism in the door lock centers on the transmission of two commands
    /// autonomously generated by the server and sent to a bound device. The assumption is that
    /// the binding mechanism will be used to commission the server to send these commands.
    /// Door locks have the ability to require the use of APS encryption for sending and
    /// receiving of all cluster messages. The Security Level attribute is used to specify the
    /// type of encryption required by the door lock.
    ///
    /// Code is auto-generated. Modifications may be overwritten!
    /// </summary>
    public class ZclDoorLockCluster : ZclCluster
    {
        /// <summary>
        /// The ZigBee Cluster Library Cluster ID
        /// </summary>
        public const ushort CLUSTER_ID = 0x0101;

        /// <summary>
        /// The ZigBee Cluster Library Cluster Name
        /// </summary>
        public const string CLUSTER_NAME = "Door Lock";

        // Attribute constants

        /// <summary>
        /// Provides the current lock state
        /// </summary>
        public const ushort ATTR_LOCKSTATE = 0x0000;

        /// <summary>
        /// Defines the type of lock
        /// </summary>
        public const ushort ATTR_LOCKTYPE = 0x0001;

        /// <summary>
        /// Boolean indicating the enabled/disabled state of the lock
        /// </summary>
        public const ushort ATTR_ACTUATORENABLED = 0x0002;

        /// <summary>
        /// The current state of the door lock
        /// </summary>
        public const ushort ATTR_DOORSTATE = 0x0003;

        /// <summary>
        /// This attribute holds the number of door open events that have occurred since it was
        /// last zeroed.
        /// </summary>
        public const ushort ATTR_DOOROPENEVENTS = 0x0004;

        /// <summary>
        /// This attribute holds the number of door closed events that have occurred since it
        /// was last zeroed.
        /// </summary>
        public const ushort ATTR_DOORCLOSEDEVENTS = 0x0005;

        /// <summary>
        /// This attribute holds the number of minutes the door has been open since the last time
        /// it transitioned from closed to open.
        /// </summary>
        public const ushort ATTR_OPENPERIOD = 0x0006;

        /// <summary>
        /// The number of available log records.
        /// </summary>
        public const ushort ATTR_NUMLOCKRECORDSSUPPORTED = 0x0010;

        /// <summary>
        /// Number of total users supported by the lock. This value is equal to the higher one of
        /// [# of PIN Users Supported] and [# of RFID Users Supported]
        /// </summary>
        public const ushort ATTR_NUMTOTALUSERSSUPPORTED = 0x0011;

        /// <summary>
        /// The number of PIN users supported.
        /// </summary>
        public const ushort ATTR_NUMPINUSERSSUPPORTED = 0x0012;

        /// <summary>
        /// The number of RFID users supported.
        /// </summary>
        public const ushort ATTR_NUMRFIDUSERSSUPPORTED = 0x0013;

        /// <summary>
        /// The number of configurable week day schedule supported per user.
        /// </summary>
        public const ushort ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER = 0x0014;

        /// <summary>
        /// The number of configurable year day schedule supported per user
        /// </summary>
        public const ushort ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER = 0x0015;

        /// <summary>
        /// The number of holiday schedules supported for the entire door lock device.
        /// </summary>
        public const ushort ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER = 0x0016;

        /// <summary>
        /// An 8 bit value indicates the maximum length in bytes of a PIN Code on this device. The
        /// default is set to 8 since most lock manufacturers currently allow PIN Codes of 8
        /// bytes or less.
        /// </summary>
        public const ushort ATTR_MAXPINLENGTH = 0x0017;

        /// <summary>
        /// An 8 bit value indicates the minimum length in bytes of a PIN Code on this device. The
        /// default is set to 4 since most lock manufacturers do not support PIN Codes that are
        /// shorter than 4 bytes.
        /// </summary>
        public const ushort ATTR_MINPINLENGTH = 0x0018;

        /// <summary>
        /// An 8 bit value indicates the maximum length in bytes of a RFID Code on this device. The
        /// value depends on the RFID code range specified by the manufacturer, if media
        /// anti-collision identifiers (UID) are used as RFID code, a value of 20 (equals 10
        /// Byte ISO 14443A UID) is recommended.
        /// </summary>
        public const ushort ATTR_MAXRFIDCODELENGTH = 0x0019;

        /// <summary>
        /// An 8 bit value indicates the minimum length in bytes of a RFID Code on this device. The
        /// value depends on the RFID code range specified by the manufacturer, if media
        /// anti-collision identifiers (UID) are used as RFID code, a value of 8 (equals 4 Byte
        /// ISO 14443A UID) is recommended.
        /// </summary>
        public const ushort ATTR_MINRFIDCODELENGTH = 0x001A;

        /// <summary>
        /// Enable/disable event logging. When event logging is enabled, all event messages
        /// are stored on the lock for retrieval. Logging events can be but not limited to Tamper
        /// Alarm, Lock, Unlock, Autolock, User Code Added, User Code Deleted, Schedule
        /// Added, and Schedule Deleted. For a full detail of all the possible alarms and
        /// events, please refer to the full list in the Alarm and Event Masks Attribute Set.
        /// </summary>
        public const ushort ATTR_ENABLELOGGING = 0x0020;

        /// <summary>
        /// Modifies the language for the on-screen or audible user interface using three
        /// bytes from ISO-639-1. It consists of one byte of length and two bytes for the
        /// language code. For example if the language is set to English, the value would be "02
        /// 65 6E" for the language code "en"
        /// </summary>
        public const ushort ATTR_LANGUAGE = 0x0021;

        /// <summary>
        /// The settings for the LED support three different modes
        /// </summary>
        public const ushort ATTR_LEDSETTINGS = 0x0022;

        /// <summary>
        /// The number of seconds to wait after unlocking a lock before it automatically locks
        /// again. 0=disabled. If set, unlock operations from any source will be timed. For one
        /// time unlock with timeout use the specific command.
        /// </summary>
        public const ushort ATTR_AUTORELOCKTIME = 0x0023;

        /// <summary>
        /// The sound volume on a door lock has three possible settings: silent, low and high
        /// volumes
        /// </summary>
        public const ushort ATTR_SOUNDVOLUME = 0x0024;

        /// <summary>
        /// Shows the current operating mode
        /// </summary>
        public const ushort ATTR_OPERATINGMODE = 0x0025;

        /// <summary>
        /// This bitmap contains all operating bits of the Operating Mode Attribute supported
        /// by the lock. The value of the enumeration in “Operating Mode” defines the related
        /// bit to be set, as shown in Table 7-16. All bits supported by a lock shall be set to zero.
        /// </summary>
        public const ushort ATTR_SUPPORTEDOPERATINGMODES = 0x0026;

        /// <summary>
        /// This attribute represents the default configurations as they are physically set
        /// on the device (example: hardware dip switch setting, etc…) and represents the
        /// default setting for some of the attributes within this Operational Setting
        /// Attribute Set (for example: LED, Auto Lock, Sound Volume, and Operating Mode
        /// attributes).
        /// This is a read-only attribute and is intended to allow clients to determine what
        /// changes may need to be made without having to query all the included attributes. It
        /// may be beneficial for the clients to know what the device’s original settings were
        /// in the event that the device needs to be restored to factory default settings.
        /// </summary>
        public const ushort ATTR_DEFAULTCONFIGURATIONREGISTER = 0x0027;

        /// <summary>
        /// Enable/disable local programming on the door lock. The local programming
        /// features includes but not limited to adding new user codes, deleting existing user
        /// codes, add new schedule, deleting existing schedule on the local door lock
        /// interfaces. If this value is set to 0x01 or TRUE then local programming is enabled on
        /// the door lock. If it is set to 0x00 or FALSE then local programming is disabled on the
        /// door lock. Local programming is enabled by default.
        /// </summary>
        public const ushort ATTR_ENABLELOCALPROGRAMMING = 0x0028;

        /// <summary>
        /// Enable/disable the ability to lock the door lock with a single touch on the door
        /// lock.
        /// </summary>
        public const ushort ATTR_ENABLEONETOUCHLOCKING = 0x0029;

        /// <summary>
        /// Enable/disable an inside LED that allows the user to see at a glance if the door is
        /// locked.
        /// </summary>
        public const ushort ATTR_ENABLEINSIDESTATUSLED = 0x002A;

        /// <summary>
        /// Enable/disable a button inside the door that is used to put the lock into privacy
        /// mode. When the lock is in privacy mode it cannot be manipulated from the outside.
        /// </summary>
        public const ushort ATTR_ENABLEPRIVACYMODEBUTTON = 0x002B;

        /// <summary>
        /// The number of incorrect codes or RFID presentment attempts a user is allowed to
        /// enter before the door will enter a lockout state. The lockout state will be for the
        /// duration of UserCodeTemporaryDisableTime.
        /// </summary>
        public const ushort ATTR_WRONGCODEENTRYLIMIT = 0x0030;

        /// <summary>
        /// The number of seconds that the lock shuts down following wrong code entry. 1-255
        /// seconds. Device can shutdown to lock user out for specified amount of time. (Makes
        /// it difficult to try and guess a PIN for the device.)
        /// </summary>
        public const ushort ATTR_USERCODETEMPORARYDISABLETIME = 0x0031;

        /// <summary>
        /// Boolean set to True if it is ok for the door lock server to send PINs over the air. This
        /// attribute determines the behavior of the server’s TX operation. If it is false,
        /// then it is not ok for the device to send PIN in any messages over the air.
        /// The PIN field within any door lock cluster message shall keep the first octet
        /// unchanged and masks the actual code by replacing with 0xFF. For example (PIN "1234"
        /// ): If the attribute value is True, 0x04 0x31 0x32 0x33 0x34 shall be used in the PIN
        /// field in any door lock cluster message payload. If the attribute value is False,
        /// 0x04 0xFF 0xFF 0xFF 0xFF shall be used.
        /// </summary>
        public const ushort ATTR_SENDPINOVERTHEAIR = 0x0032;

        /// <summary>
        /// Boolean set to True if the door lock server requires that an optional PINs be
        /// included in the payload of RF lock operation events like Lock, Unlock and Toggle in
        /// order to function.
        /// </summary>
        public const ushort ATTR_REQUIREPINFORRFOPERATION = 0x0033;

        /// <summary>
        /// Door locks may sometimes wish to implement a higher level of security within the
        /// application protocol in additional to the default network security. For instance
        /// a door lock may wish to use additional APS security for cluster transactions. This
        /// protects the door lock against being controlled by any other devices which have
        /// access to the network key.
        /// The Security Level attribute allows the door lock manufacturer to indicate what
        /// level of security the doorlock requires.
        /// </summary>
        public const ushort ATTR_ZIGBEESECURITYLEVEL = 0x0034;

        /// <summary>
        /// The alarm mask is used to turn on/off alarms for particular functions. Alarms for an
        /// alarm group are enabled if the associated alarm mask bit is set. Each bit represents
        /// a group of alarms. Entire alarm groups can be turned on or off by setting or clearing
        /// the associated bit in the alarm mask.
        /// </summary>
        public const ushort ATTR_ALARMMASK = 0x0040;

        /// <summary>
        /// Event mask used to turn on and off the transmission of keypad operation events. This
        /// mask DOES NOT apply to the storing of events in the report table.
        /// </summary>
        public const ushort ATTR_KEYPADOPERATIONEVENTMASK = 0x0041;

        /// <summary>
        /// Event mask used to turn on and off the transmission of RF operation events. This mask
        /// DOES NOT apply to the storing of events in the report table.
        /// </summary>
        public const ushort ATTR_RFOPERATIONEVENTMASK = 0x0042;

        /// <summary>
        /// Event mask used to turn on and off manual operation events. This mask DOES NOT apply
        /// to the storing of events in the report table.
        /// </summary>
        public const ushort ATTR_MANUALOPERATIONEVENTMASK = 0x0043;

        /// <summary>
        /// Event mask used to turn on and off RFID operation events. This mask DOES NOT apply to
        /// the storing of events in the report table.
        /// </summary>
        public const ushort ATTR_RFIDOPERATIONEVENTMASK = 0x0044;

        /// <summary>
        /// Event mask used to turn on and off keypad programming events. This mask DOES NOT
        /// apply to the storing of events in the report table.
        /// </summary>
        public const ushort ATTR_KEYPADPROGRAMMINGEVENTMASK = 0x0045;

        /// <summary>
        /// Event mask used to turn on and off RF programming events. This mask DOES NOT apply to
        /// the storing of events in the report table.
        /// </summary>
        public const ushort ATTR_RFPROGRAMMINGEVENTMASK = 0x0046;

        /// <summary>
        /// Event mask used to turn on and off RFID programming events. This mask DOES NOT apply
        /// to the storing of events in the report table.
        /// </summary>
        public const ushort ATTR_RFIDPROGRAMMINGEVENTMASK = 0x0047;

        protected override Dictionary<ushort, ZclAttribute> InitializeClientAttributes()
        {
            Dictionary<ushort, ZclAttribute> attributeMap = new Dictionary<ushort, ZclAttribute>(0);

            return attributeMap;
        }

        protected override Dictionary<ushort, ZclAttribute> InitializeServerAttributes()
        {
            Dictionary<ushort, ZclAttribute> attributeMap = new Dictionary<ushort, ZclAttribute>(43);

            attributeMap.Add(ATTR_LOCKSTATE, new ZclAttribute(this, ATTR_LOCKSTATE, "Lock State", ZclDataType.Get(DataType.ENUMERATION_8_BIT), true, true, false, false));
            attributeMap.Add(ATTR_LOCKTYPE, new ZclAttribute(this, ATTR_LOCKTYPE, "Lock Type", ZclDataType.Get(DataType.ENUMERATION_8_BIT), true, true, false, false));
            attributeMap.Add(ATTR_ACTUATORENABLED, new ZclAttribute(this, ATTR_ACTUATORENABLED, "Actuator Enabled", ZclDataType.Get(DataType.BOOLEAN), true, true, false, false));
            attributeMap.Add(ATTR_DOORSTATE, new ZclAttribute(this, ATTR_DOORSTATE, "Door State", ZclDataType.Get(DataType.ENUMERATION_8_BIT), true, true, false, false));
            attributeMap.Add(ATTR_DOOROPENEVENTS, new ZclAttribute(this, ATTR_DOOROPENEVENTS, "Door Open Events", ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER), false, true, true, true));
            attributeMap.Add(ATTR_DOORCLOSEDEVENTS, new ZclAttribute(this, ATTR_DOORCLOSEDEVENTS, "Door Closed Events", ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER), false, true, true, true));
            attributeMap.Add(ATTR_OPENPERIOD, new ZclAttribute(this, ATTR_OPENPERIOD, "Open Period", ZclDataType.Get(DataType.UNSIGNED_16_BIT_INTEGER), false, true, true, true));
            attributeMap.Add(ATTR_NUMLOCKRECORDSSUPPORTED, new ZclAttribute(this, ATTR_NUMLOCKRECORDSSUPPORTED, "Num Lock Records Supported", ZclDataType.Get(DataType.UNSIGNED_16_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_NUMTOTALUSERSSUPPORTED, new ZclAttribute(this, ATTR_NUMTOTALUSERSSUPPORTED, "Num Total Users Supported", ZclDataType.Get(DataType.UNSIGNED_16_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_NUMPINUSERSSUPPORTED, new ZclAttribute(this, ATTR_NUMPINUSERSSUPPORTED, "Num PIN Users Supported", ZclDataType.Get(DataType.UNSIGNED_16_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_NUMRFIDUSERSSUPPORTED, new ZclAttribute(this, ATTR_NUMRFIDUSERSSUPPORTED, "Num RFID Users Supported", ZclDataType.Get(DataType.UNSIGNED_16_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER, new ZclAttribute(this, ATTR_NUMWEEKDAYSCHEDULESSUPPORTEDPERUSER, "Num Weekday Schedules Supported Per User", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER, new ZclAttribute(this, ATTR_NUMYEARDAYSCHEDULESSUPPORTEDPERUSER, "Num Yearday Schedules Supported Per User", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER, new ZclAttribute(this, ATTR_NUMHOLIDAYSCHEDULESSUPPORTEDPERUSER, "Num Holiday Schedules Supported Per User", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_MAXPINLENGTH, new ZclAttribute(this, ATTR_MAXPINLENGTH, "Max PIN Length", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_MINPINLENGTH, new ZclAttribute(this, ATTR_MINPINLENGTH, "Min PIN Length", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_MAXRFIDCODELENGTH, new ZclAttribute(this, ATTR_MAXRFIDCODELENGTH, "Max RFID Code Length", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_MINRFIDCODELENGTH, new ZclAttribute(this, ATTR_MINRFIDCODELENGTH, "Min RFID Code Length", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), true, true, false, false));
            attributeMap.Add(ATTR_ENABLELOGGING, new ZclAttribute(this, ATTR_ENABLELOGGING, "Enable Logging", ZclDataType.Get(DataType.BOOLEAN), false, true, true, true));
            attributeMap.Add(ATTR_LANGUAGE, new ZclAttribute(this, ATTR_LANGUAGE, "Language", ZclDataType.Get(DataType.CHARACTER_STRING), false, true, true, true));
            attributeMap.Add(ATTR_LEDSETTINGS, new ZclAttribute(this, ATTR_LEDSETTINGS, "LED Settings", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), false, true, true, true));
            attributeMap.Add(ATTR_AUTORELOCKTIME, new ZclAttribute(this, ATTR_AUTORELOCKTIME, "Auto Relock Time", ZclDataType.Get(DataType.UNSIGNED_32_BIT_INTEGER), false, true, true, true));
            attributeMap.Add(ATTR_SOUNDVOLUME, new ZclAttribute(this, ATTR_SOUNDVOLUME, "Sound Volume", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), false, true, true, true));
            attributeMap.Add(ATTR_OPERATINGMODE, new ZclAttribute(this, ATTR_OPERATINGMODE, "Operating Mode", ZclDataType.Get(DataType.ENUMERATION_8_BIT), false, true, true, true));
            attributeMap.Add(ATTR_SUPPORTEDOPERATINGMODES, new ZclAttribute(this, ATTR_SUPPORTEDOPERATINGMODES, "Supported Operating Modes", ZclDataType.Get(DataType.BITMAP_16_BIT), true, true, false, false));
            attributeMap.Add(ATTR_DEFAULTCONFIGURATIONREGISTER, new ZclAttribute(this, ATTR_DEFAULTCONFIGURATIONREGISTER, "Default Configuration Register", ZclDataType.Get(DataType.BITMAP_16_BIT), true, true, false, false));
            attributeMap.Add(ATTR_ENABLELOCALPROGRAMMING, new ZclAttribute(this, ATTR_ENABLELOCALPROGRAMMING, "Enable Local Programming", ZclDataType.Get(DataType.BOOLEAN), false, true, true, true));
            attributeMap.Add(ATTR_ENABLEONETOUCHLOCKING, new ZclAttribute(this, ATTR_ENABLEONETOUCHLOCKING, "Enable One Touch Locking", ZclDataType.Get(DataType.BOOLEAN), false, true, true, true));
            attributeMap.Add(ATTR_ENABLEINSIDESTATUSLED, new ZclAttribute(this, ATTR_ENABLEINSIDESTATUSLED, "Enable Inside Status Led", ZclDataType.Get(DataType.BOOLEAN), false, true, true, true));
            attributeMap.Add(ATTR_ENABLEPRIVACYMODEBUTTON, new ZclAttribute(this, ATTR_ENABLEPRIVACYMODEBUTTON, "Enable Privacy Mode Button", ZclDataType.Get(DataType.BOOLEAN), false, true, true, true));
            attributeMap.Add(ATTR_WRONGCODEENTRYLIMIT, new ZclAttribute(this, ATTR_WRONGCODEENTRYLIMIT, "Wrong Code Entry Limit", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), false, true, true, true));
            attributeMap.Add(ATTR_USERCODETEMPORARYDISABLETIME, new ZclAttribute(this, ATTR_USERCODETEMPORARYDISABLETIME, "User Code Temporary Disable Time", ZclDataType.Get(DataType.UNSIGNED_8_BIT_INTEGER), false, true, true, true));
            attributeMap.Add(ATTR_SENDPINOVERTHEAIR, new ZclAttribute(this, ATTR_SENDPINOVERTHEAIR, "Send PIN Over The Air", ZclDataType.Get(DataType.BOOLEAN), false, true, true, true));
            attributeMap.Add(ATTR_REQUIREPINFORRFOPERATION, new ZclAttribute(this, ATTR_REQUIREPINFORRFOPERATION, "Require PIN For RF Operation", ZclDataType.Get(DataType.BOOLEAN), false, true, true, true));
            attributeMap.Add(ATTR_ZIGBEESECURITYLEVEL, new ZclAttribute(this, ATTR_ZIGBEESECURITYLEVEL, "ZigBee Security Level", ZclDataType.Get(DataType.ENUMERATION_8_BIT), true, true, false, false));
            attributeMap.Add(ATTR_ALARMMASK, new ZclAttribute(this, ATTR_ALARMMASK, "Alarm Mask", ZclDataType.Get(DataType.BITMAP_16_BIT), false, true, true, true));
            attributeMap.Add(ATTR_KEYPADOPERATIONEVENTMASK, new ZclAttribute(this, ATTR_KEYPADOPERATIONEVENTMASK, "Keypad Operation Event Mask", ZclDataType.Get(DataType.BITMAP_16_BIT), false, true, true, true));
            attributeMap.Add(ATTR_RFOPERATIONEVENTMASK, new ZclAttribute(this, ATTR_RFOPERATIONEVENTMASK, "RF Operation Event Mask", ZclDataType.Get(DataType.BITMAP_16_BIT), false, true, true, true));
            attributeMap.Add(ATTR_MANUALOPERATIONEVENTMASK, new ZclAttribute(this, ATTR_MANUALOPERATIONEVENTMASK, "Manual Operation Event Mask", ZclDataType.Get(DataType.BITMAP_16_BIT), false, true, true, true));
            attributeMap.Add(ATTR_RFIDOPERATIONEVENTMASK, new ZclAttribute(this, ATTR_RFIDOPERATIONEVENTMASK, "RFID Operation Event Mask", ZclDataType.Get(DataType.BITMAP_16_BIT), false, true, true, true));
            attributeMap.Add(ATTR_KEYPADPROGRAMMINGEVENTMASK, new ZclAttribute(this, ATTR_KEYPADPROGRAMMINGEVENTMASK, "Keypad Programming Event Mask", ZclDataType.Get(DataType.BITMAP_16_BIT), false, true, true, true));
            attributeMap.Add(ATTR_RFPROGRAMMINGEVENTMASK, new ZclAttribute(this, ATTR_RFPROGRAMMINGEVENTMASK, "RF Programming Event Mask", ZclDataType.Get(DataType.BITMAP_16_BIT), false, true, true, true));
            attributeMap.Add(ATTR_RFIDPROGRAMMINGEVENTMASK, new ZclAttribute(this, ATTR_RFIDPROGRAMMINGEVENTMASK, "RFID Programming Event Mask", ZclDataType.Get(DataType.BITMAP_16_BIT), false, true, true, true));

            return attributeMap;
        }

        protected override Dictionary<ushort, Func<ZclCommand>> InitializeServerCommands()
        {
            Dictionary<ushort, Func<ZclCommand>> commandMap = new Dictionary<ushort, Func<ZclCommand>>(4);

            commandMap.Add(0x0000, () => new LockDoorResponse());
            commandMap.Add(0x0001, () => new UnlockDoorResponse());
            commandMap.Add(0x0002, () => new ToggleResponse());
            commandMap.Add(0x0003, () => new UnlockWithTimeoutResponse());

            return commandMap;
        }

        protected override Dictionary<ushort, Func<ZclCommand>> InitializeClientCommands()
        {
            Dictionary<ushort, Func<ZclCommand>> commandMap = new Dictionary<ushort, Func<ZclCommand>>(4);

            commandMap.Add(0x0000, () => new LockDoorCommand());
            commandMap.Add(0x0001, () => new UnlockDoorCommand());
            commandMap.Add(0x0002, () => new Toggle());
            commandMap.Add(0x0003, () => new UnlockWithTimeout());

            return commandMap;
        }

        /// <summary>
        /// Default constructor to create a Door Lock cluster.
        ///
        /// <param name="zigbeeEndpoint"> the ZigBeeEndpoint this cluster is contained within </param>
        /// </summary>
        public ZclDoorLockCluster(ZigBeeEndpoint zigbeeEndpoint)
            :base(zigbeeEndpoint, CLUSTER_ID, CLUSTER_NAME)
        {
        }

        /// <summary>
        /// The Lock Door Command
        ///
        /// This command causes the lock device to lock the door. As of HA 1.2, this command
        /// includes an optional code for the lock. The door lock may require a PIN depending on
        /// the value of the [Require PIN for RF Operation attribute]
        ///
        /// <param name="pinCode" <see cref="ByteArray"> PIN Code</ param >
        /// <returns> the command result Task </returns>
        /// </summary>
        public Task<CommandResult> LockDoorCommand(ByteArray pinCode)
        {
            LockDoorCommand command = new LockDoorCommand();

            // Set the fields
            command.PinCode = pinCode;

            return Send(command);
        }

        /// <summary>
        /// The Unlock Door Command
        ///
        /// This command causes the lock device to unlock the door. As of HA 1.2, this command
        /// includes an optional code for the lock. The door lock may require a code depending on
        /// the value of the [Require PIN for RF Operation attribute].
        ///
        /// Note: If the attribute AutoRelockTime is supported the lock will close when the auto
        /// relock time has expired
        ///
        /// <param name="pinCode" <see cref="ByteArray"> PIN Code</ param >
        /// <returns> the command result Task </returns>
        /// </summary>
        public Task<CommandResult> UnlockDoorCommand(ByteArray pinCode)
        {
            UnlockDoorCommand command = new UnlockDoorCommand();

            // Set the fields
            command.PinCode = pinCode;

            return Send(command);
        }

        /// <summary>
        /// The Toggle
        ///
        /// Request the status of the lock. As of HA 1.2, this command includes an optional code
        /// for the lock. The door lock may require a code depending on the value of the [Require
        /// PIN for RF Operation attribute]
        ///
        /// <param name="pin" <see cref="string"> PIN</ param >
        /// <returns> the command result Task </returns>
        /// </summary>
        public Task<CommandResult> Toggle(string pin)
        {
            Toggle command = new Toggle();

            // Set the fields
            command.Pin = pin;

            return Send(command);
        }

        /// <summary>
        /// The Unlock With Timeout
        ///
        /// This command causes the lock device to unlock the door with a timeout parameter.
        /// After the time in seconds specified in the timeout field, the lock device will
        /// relock itself automatically. This timeout parameter is only temporary for this
        /// message transition only and overrides the default relock time as specified in the
        /// [Auto Relock Time attribute] attribute. If the door lock device is not capable of or
        /// does not want to support temporary Relock Timeout, it should not support this
        /// optional command.
        ///
        /// <param name="timeoutInSeconds" <see cref="ushort"> Timeout In Seconds</ param >
        /// <param name="pin" <see cref="string"> PIN</ param >
        /// <returns> the command result Task </returns>
        /// </summary>
        public Task<CommandResult> UnlockWithTimeout(ushort timeoutInSeconds, string pin)
        {
            UnlockWithTimeout command = new UnlockWithTimeout();

            // Set the fields
            command.TimeoutInSeconds = timeoutInSeconds;
            command.Pin = pin;

            return Send(command);
        }

        /// <summary>
        /// The Lock Door Response
        ///
        /// This command is sent in response to a Lock command with one status byte payload. The
        /// Status field shall be set to SUCCESS or FAILURE.
        /// The status byte only indicates if the message has received successfully. To
        /// determine the lock and/or door status, the client should query to [Lock State
        /// attribute] and [Door State attribute]
        ///
        /// <param name="status" <see cref="byte"> Status</ param >
        /// <returns> the command result Task </returns>
        /// </summary>
        public Task<CommandResult> LockDoorResponse(byte status)
        {
            LockDoorResponse command = new LockDoorResponse();

            // Set the fields
            command.Status = status;

            return Send(command);
        }

        /// <summary>
        /// The Unlock Door Response
        ///
        /// This command is sent in response to a Toggle command with one status byte payload.
        /// The Status field shall be set to SUCCESS or FAILURE.
        /// The status byte only indicates if the message has received successfully. To
        /// determine the lock and/or door status, the client should query to [Lock State
        /// attribute] and [Door State attribute].
        ///
        /// <param name="status" <see cref="byte"> Status</ param >
        /// <returns> the command result Task </returns>
        /// </summary>
        public Task<CommandResult> UnlockDoorResponse(byte status)
        {
            UnlockDoorResponse command = new UnlockDoorResponse();

            // Set the fields
            command.Status = status;

            return Send(command);
        }

        /// <summary>
        /// The Toggle Response
        ///
        /// This command is sent in response to a Toggle command with one status byte payload.
        /// The Status field shall be set to SUCCESS or FAILURE.
        /// The status byte only indicates if the message has received successfully. To
        /// determine the lock and/or door status, the client should query to [Lock State
        /// attribute] and [Door State attribute].
        ///
        /// <param name="status" <see cref="byte"> Status</ param >
        /// <returns> the command result Task </returns>
        /// </summary>
        public Task<CommandResult> ToggleResponse(byte status)
        {
            ToggleResponse command = new ToggleResponse();

            // Set the fields
            command.Status = status;

            return Send(command);
        }

        /// <summary>
        /// The Unlock With Timeout Response
        ///
        /// This command is sent in response to an Unlock with Timeout command with one status
        /// byte payload. The Status field shall be set to SUCCESS or FAILURE.
        /// The status byte only indicates if the message has received successfully. To
        /// determine status, the client should query to [Lock State attribute] and [Door
        /// State attribute].
        ///
        /// <param name="status" <see cref="byte"> Status</ param >
        /// <returns> the command result Task </returns>
        /// </summary>
        public Task<CommandResult> UnlockWithTimeoutResponse(byte status)
        {
            UnlockWithTimeoutResponse command = new UnlockWithTimeoutResponse();

            // Set the fields
            command.Status = status;

            return Send(command);
        }
    }
}
